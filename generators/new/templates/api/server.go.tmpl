package api

import (
  "context"
  "log"
  "net/http"
  "strconv"

  "github.com/99designs/gqlgen/graphql"
  "github.com/99designs/gqlgen/graphql/handler"
  "github.com/go-chi/chi"
  "github.com/go-chi/chi/middleware"
  "github.com/go-chi/cors"
  "github.com/gobuffalo/pop"
  "{{ .opts.Package }}/api/resolvers"
  "{{ .opts.Package }}/generated"
)

type Server struct {
  config  *Config
  db      *pop.Connection
  handler http.Handler
}

func (server *Server) ListenAndServe() error {
  defer server.db.Close()

  port := server.config.Server.Port
  if port == 0 {
    port = 8080
  }

  log.Printf("listening on http://localhost:%d", port)
  log.Fatal(http.ListenAndServe(":"+strconv.Itoa(port), server.handler))
  return nil
}

func NewServer() (*Server, error) {
  config, err := GetConfig()
  if err != nil {
    return nil, err
  }

  // TODO: context
  // ctx := context.Background()
  server := &Server{
    config: config,
  }

  conn, err := pop.NewConnection(config.Database)
  if err != nil {
    return nil, err
  }

  err = conn.Open()
  if err != nil {
    return nil, err
  }

  server.db = conn

  router := chi.NewRouter()
  router.Use(middleware.RequestID)
  router.Use(middleware.RealIP)
  router.Use(middleware.Logger)
  router.Use(middleware.Recoverer)

  cors := cors.New(cors.Options{
    AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete},
    AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type"},
    AllowCredentials: true,
  })

  router.Use(cors.Handler)

  graphqlConfig := generated.Config{
    Resolvers: &resolvers.Resolver{
      Conn: conn,
    },
  }
  graphqlConfig.Directives.Generated = func(ctx context.Context, obj interface{}, next graphql.Resolver, typeArg string) (interface{}, error) {
    return next(ctx)
  }
  graphql := handler.NewDefaultServer(generated.NewExecutableSchema(graphqlConfig))

  router.Handle("/graphql", graphql)

  server.handler = router

  return server, nil
}

package dashi

import (
  "log"
  "net/http"
  "strconv"

  "github.com/99designs/gqlgen/graphql/handler"
  "github.com/go-chi/chi"
  "github.com/go-chi/cors"
  "github.com/gobuffalo/pop"
  "github.com/spf13/viper"
  "{{ .opts.Package }}/graphql"
  "{{ .opts.Package }}/resolvers"
)

type Server struct {
  config  *Config
  db      *pop.Connection
  handler http.Handler
}

func (server *Server) ListenAndServe() error {
  defer server.db.Close()

  port := server.config.Server.Port
  if port == 0 {
    port = 8080
  }

  log.Printf("listening on http://localhost:%d", port)
  log.Fatal(http.ListenAndServe(":"+strconv.Itoa(port), server.handler))
  return nil
}

func GetConfig() (*Config, error) {
  config := Config{}
  err := viper.Unmarshal(&config)
  if err != nil {
    return nil, err
  }

  return &config, nil
}

func NewServer() (*Server, error) {
  config, err := GetConfig()
  if err != nil {
    return nil, err
  }

  // TODO: context
  // ctx := context.Background()
  server := &Server{
    config: config,
  }

  conn, err := server.GetDatabase()
  if err != nil {
    return nil, err
  }

  router := chi.NewRouter()

  cors := cors.New(cors.Options{
    AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete},
    AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type"},
    AllowCredentials: true,
  })

  router.Use(cors.Handler)

  graphql := handler.NewDefaultServer(graphql.NewExecutableSchema(graphql.Config{
    Resolvers: &resolvers.Resolver{
      Conn: conn,
    },
  }))

  router.Handle("/graphql", graphql)

  server.handler = router

  return server, nil
}
